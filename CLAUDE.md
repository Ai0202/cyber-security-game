# CyberGuardians

## 概要

「攻撃者の目線で学ぶ、サイバーセキュリティ体験学習」をコンセプトとした体験型セキュリティ教育ゲーム。一般の会社員・主婦・学生を対象に、攻撃者側を体験することで実践的なセキュリティリテラシーを身につけることを目的とする。ハッカソンプロジェクトとして開発するMVPである。

## 技術スタック

- フロントエンド: Next.js (App Router) + TypeScript + Tailwind CSS
- アニメーション: Framer Motion
- AI: Google Gemini API（`@google/generative-ai` SDK を使用）
- データ定義: JSONファイル（`src/data/`）。将来的にRDBに移行予定
- 状態管理: React Context（クライアントサイド）
- デプロイ: Google Cloud Run（Dockerfile で Next.js をビルド・配信）

## ゲーム構造

ゲームは「ストーリー（攻撃テーマ）→ フェーズ → コンポーネント」の3層構造:

- **ストーリー（Story）**: プレイヤーが選ぶ攻撃テーマ（例: 病院の患者情報を盗め）
- **フェーズ（Phase）**: 攻撃チェーンの4段階（情報収集→認証窃取→侵入→目的達成）
- **コンポーネント（Component）**: 各フェーズで使える個別の攻撃手法ミニゲーム（例: ショルダーハッキング、フィッシング）
- **セッション（Session）**: 1回のプレイスルー全体

各ストーリーのフェーズごとにコンポーネントプール（候補群）が定義され、プレイ時にランダムに選ばれる。

## ドキュメント構成

- docs/overview.md: システム概要・コンセプト・スコープ
- docs/features.md: 機能一覧（フェーズ・コンポーネントの詳細ゲーム仕様）
- docs/architecture.md: アーキテクチャ・ディレクトリ構成
- docs/er-diagram.md: データモデル・型定義・将来のER図
- docs/openapi.yaml: API仕様
- docs/plans/: 実装計画・設計ドキュメント

## 開発ルール

### 実装前

- `/create-plan` コマンドで実装計画を立案する
- 該当する画面・機能のドキュメントを確認する
- 不明点があれば実装前に質問する

### 実装時

- docs/plans/ の計画ファイルを参照しながら実装する
- テストを同時に書く
- リンターを実行する

### タスク完了時

- 計画ファイルのタスクにチェックを入れる（`- [x]`）

### 実装完了時

- セルフレビューを実施する
- 受入テストを含め、実装した機能のすべてのテストを実施する
- 仕様変更があればドキュメントにフィードバック（features.md, openapi.yaml等を更新）
- 計画ファイルの備考に実装中の気づきを記録

### コミット規約

- feat: 新機能
- fix: バグ修正
- docs: ドキュメント
- refactor: リファクタリング
- chore: 雑務（依存関係更新、設定変更等）

## プロジェクト固有ルール

### UI/デザイン

- **サイバーパンク風ダークテーマ**: 背景は `#0a0a1a`、カードは `#1a1a2e`、アクセントにネオングリーン・マゼンタグラデーションを使用
- **Framer Motionを全アニメーションに使用**: ページ遷移は `AnimatePresence`、カードはホバー/タップアニメーション、テキストはタイプライターエフェクト。CSS animation や transition は使わず Framer Motion に統一する
- **モバイルファースト**: UIモックアップはモバイル基準。PC表示は `max-w-md mx-auto` で中央寄せ
- **フォント**: 日本語は Noto Sans JP、英語・コード表示は JetBrains Mono
- **日本語**: UIのテキストは日本語。ただしストーリー名（OPERATION: HOSPITAL BREACH 等）やフェーズ名（RECONNAISSANCE 等）は英語

### Gemini API

- **APIキーの秘匿**: Gemini APIの呼び出しは必ず Next.js API Routes (`app/api/game/`) 経由。クライアントサイドから直接呼び出さない
- **環境変数**: `GEMINI_API_KEY` で管理。`.env.local` に設定
- **SDKの使用**: `@google/generative-ai` パッケージを使用する
- **構造化レスポンス**: Gemini APIへのプロンプトでは必ず JSON 形式でのレスポンスを指示し、型安全にパースする
- **プロンプト管理**: 各コンポーネントのプロンプトは `src/lib/prompts/` に専用ファイルとして管理。`common.ts` でストーリーコンテキストを注入。システムプロンプトとユーザープロンプトを分離する
- **エラーハンドリング**: API呼び出し失敗時はフォールバックのハードコードシナリオを用意する
- **ストリーミング**: 結果画面のAIフィードバックは `generateContentStream` でストリーミング表示する

### ゲーム設計

- **ストーリーモード**: ストーリーを選び、4フェーズの攻撃チェーンを順番にプレイ。フェーズごとにコンポーネントがランダム選択される
- **練習モード**: コンポーネント単体でもプレイ可能。ストーリーコンテキストなしのデフォルトシナリオを使用
- **フェーズ間コンテキスト引き継ぎ**: 前フェーズの成果（発見した情報、窃取した認証情報等）が次フェーズに引き継がれる
- **スコアリング**: 各コンポーネント 0〜100点。docs/features.md のスコアリング表に基づく
- **ランク判定**: S (90-100), A (70-89), B (50-69), C (30-49), D (0-29)
- **毎回異なるシナリオ**: Gemini APIで動的生成 + コンポーネントのランダム組み合わせで同じプレイ体験にならない
- **教育目的を忘れない**: ゲーム体験は楽しくするが、結果画面では必ず「現実でどう防御するか」の学習ポイントを提示する

### コンポーネント別の実装方針

#### ショルダーハッキング（recon）
- **形式**: 制限時間つき画像探索ゲーム
- **UI**: ストーリーコンテキストに合わせたシーン上にPC・スマホ画面のモックをオーバーレイ表示。タップで情報を収集
- **Gemini**: ストーリーコンテキストを反映したシチュエーション（場所・ターゲット・画面内容）を生成
- **制限時間**: 30秒

#### パスワードクラッキング（credential）
- **形式**: ターミナル風UIでのパスワード推測シミュレーション
- **UI**: 上半分にターゲットのSNSプロフィール（カード形式）、下半分にターミナル風入力エリア
- **Gemini**: ターゲットプロフィールと正解パスワード（複数候補、推測理由付き）を生成
- **3つの攻撃モード**: 手動推測（テキスト入力）、辞書攻撃（リスト選択）、総当たり（設定＋自動実行アニメーション）

#### フィッシング攻撃（credential）
- **形式**: メーラー風UIでのフィッシングメール作成シミュレーション
- **UI**: メール作成フォーム（差出人・件名・本文・リンク/添付）。プレビュー表示機能あり
- **Gemini**: ターゲット情報を生成。作成したメールの「騙されやすさ」を多角的に評価
- **ターゲットの反応**: Gemini がストーリー形式で生成

#### ネットワーク侵入（intrusion）
- **形式**: ネットワークマップ探索 + ターミナル風UI
- **UI**: ネットワークマップ上のノードをクリックして探索。権限昇格の選択肢
- **Gemini**: ストーリーコンテキストに合わせた企業ネットワーク構成を動的生成

#### ランサムウェア展開（objective）
- **形式**: ファイル暗号化シミュレーション + 脅迫文作成
- **UI**: 前フェーズの成果を反映したファイルグリッド。暗号化アニメーション
- **Gemini**: 全フェーズの行動ログから最終評価レポートを生成
- **暗号化演出**: ファイルアイコンが次々とロックアイコンに変わるアニメーション（Framer Motion の staggerChildren）

### コード品質

- TypeScript strict mode を有効にする
- Gemini APIのレスポンスは Zod でバリデーションする
- コンポーネントは1ファイル200行以内を目安に分割する
- `use client` の指定は必要な場合のみ（Framer Motion やイベントハンドラを含むコンポーネント）
