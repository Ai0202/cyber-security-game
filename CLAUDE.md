# CyberGuardians

## 概要

「攻撃者の目線で学ぶ、サイバーセキュリティ体験学習」をコンセプトとした体験型セキュリティ教育ゲーム。一般の会社員・主婦・学生を対象に、攻撃者側を体験することで実践的なセキュリティリテラシーを身につけることを目的とする。ハッカソンプロジェクトとして開発するMVPである。

## 技術スタック

- フロントエンド: Next.js (App Router) + TypeScript + Tailwind CSS
- アニメーション: Framer Motion
- AI: Google Gemini API（`@google/generative-ai` SDK を使用）
- データベース: なし（MVP。状態はクライアントサイドの React Context で管理）
- デプロイ: Google Cloud Run（Dockerfile で Next.js をビルド・配信）

## ドキュメント構成

- docs/overview.md: システム概要・コンセプト・スコープ
- docs/features.md: 機能一覧（全4ステージの詳細ゲーム仕様）
- docs/architecture.md: アーキテクチャ・ディレクトリ構成
- docs/api/openapi.yaml: API仕様（Gemini APIプロキシ）
- docs/screens/index.md: 画面一覧・画面遷移・デザインシステム
- docs/decisions/: ADR（Architecture Decision Records）
- docs/plans/: 実装計画

## 開発ルール

### 実装前

- `/create-plan` コマンドで実装計画を立案する
- 該当する画面・機能のドキュメントを確認する
- 不明点があれば実装前に質問する

### 実装時

- docs/plans/ の計画ファイルを参照しながら実装する
- テストを同時に書く
- リンターを実行する

### タスク完了時

- 計画ファイルのタスクにチェックを入れる（`- [x]`）

### 実装完了時

- セルフレビューを実施する
- 受入テストを含め、実装した機能のすべてのテストを実施する
- 仕様変更があればドキュメントにフィードバック（features.md, openapi.yaml等を更新）
- 計画ファイルの備考に実装中の気づきを記録

### コミット規約

- feat: 新機能
- fix: バグ修正
- docs: ドキュメント
- refactor: リファクタリング
- chore: 雑務（依存関係更新、設定変更等）

## プロジェクト固有ルール

### UI/デザイン

- **サイバーパンク風ダークテーマ**: 背景は `#0a0a1a`、カードは `#1a1a2e`、アクセントにネオングリーン・マゼンタグラデーションを使用。docs/screens/index.md のカラーパレットを厳守すること
- **Framer Motionを全アニメーションに使用**: ページ遷移は `AnimatePresence`、カードはホバー/タップアニメーション、テキストはタイプライターエフェクト。CSS animation や transition は使わず Framer Motion に統一する
- **モバイルファースト**: UIモックアップはモバイル基準。PC表示は `max-w-md mx-auto` で中央寄せ
- **フォント**: 日本語は Noto Sans JP、英語・コード表示は JetBrains Mono
- **日本語**: UIのテキストは日本語。ただしステージ名（OPERATION: RANSOMWARE 等）やセクション名（ATTACK SIDE 等）は英語

### Gemini API

- **APIキーの秘匿**: Gemini APIの呼び出しは必ず Next.js API Routes (`app/api/gemini/`) 経由。クライアントサイドから直接呼び出さない
- **環境変数**: `GEMINI_API_KEY` で管理。`.env.local` に設定
- **SDKの使用**: `@google/generative-ai` パッケージを使用する
- **構造化レスポンス**: Gemini APIへのプロンプトでは必ず JSON 形式でのレスポンスを指示し、型安全にパースする
- **プロンプト管理**: 各ステージのプロンプトは `src/lib/prompts/` に専用ファイルとして管理。システムプロンプトとユーザープロンプトを分離する
- **エラーハンドリング**: API呼び出し失敗時はフォールバックのハードコードシナリオを用意する
- **ストリーミング**: 結果画面のAIフィードバックは `generateContentStream` でストリーミング表示する

### ゲーム設計

- **各ステージは独立動作**: ステージ間の依存関係はなし（OPERATIONモード以外）。どのステージからでもプレイ開始可能
- **スコアリング**: 各ステージ 0〜100点。docs/features.md のスコアリング表に基づく
- **ランク判定**: S (90-100), A (70-89), B (50-69), C (30-49), D (0-29)
- **毎回異なるシナリオ**: Gemini APIで動的生成。同じプレイ体験にならないこと
- **教育目的を忘れない**: ゲーム体験は楽しくするが、結果画面では必ず「現実でどう防御するか」の学習ポイントを提示する

### ステージ別の実装方針

#### Stage 1: ショルダーハッキング
- **形式**: 制限時間つき画像探索ゲーム
- **UI**: カフェ/オフィスのシーン上にPC・スマホ画面のモックをオーバーレイ表示。タップで情報を収集
- **Gemini**: シチュエーション（場所・ターゲット・画面内容）を生成。レスポンスには発見すべき情報リスト（座標ヒント付き）を含める
- **制限時間**: 30秒

#### Stage 2: パスワードクラッキング
- **形式**: ターミナル風UIでのパスワード推測シミュレーション
- **UI**: 上半分にターゲットのSNSプロフィール（カード形式）、下半分にターミナル風入力エリア
- **Gemini**: ターゲットプロフィールと正解パスワード（複数候補、推測理由付き）を生成
- **3つの攻撃モード**: 手動推測（テキスト入力）、辞書攻撃（リスト選択）、総当たり（設定＋自動実行アニメーション）

#### Stage 3: フィッシング攻撃
- **形式**: メーラー風UIでのフィッシングメール作成シミュレーション
- **UI**: メール作成フォーム（差出人・件名・本文・リンク/添付）。プレビュー表示機能あり
- **Gemini**: ターゲット情報を生成。作成したメールの「騙されやすさ」を多角的に評価（送信者偽装・件名・本文・URL の各項目をスコアリング）
- **ターゲットの反応**: Gemini がストーリー形式で生成（「リンクをクリックした」「怪しいと思って無視した」等）

#### Stage 4: ランサムウェア侵攻
- **形式**: 4フェーズのストーリー分岐型ゲーム + ターミナル風UI
- **フェーズ**: 初期侵入 → 内部偵察 → 権限昇格・暗号化 → 身代金要求
- **UI**: 各フェーズで選択肢を表示。選択結果に応じてGeminiがストーリーを進行
- **Gemini**: 企業システム構成を動的生成。各選択に対する結果をJSON形式で返す。フェーズ間の文脈を会話履歴として維持
- **暗号化演出**: ファイルアイコンが次々とロックアイコンに変わるアニメーション（Framer Motion の staggerChildren）

### コード品質

- TypeScript strict mode を有効にする
- Gemini APIのレスポンスは Zod でバリデーションする
- コンポーネントは1ファイル200行以内を目安に分割する
- `use client` の指定は必要な場合のみ（Framer Motion やイベントハンドラを含むコンポーネント）
